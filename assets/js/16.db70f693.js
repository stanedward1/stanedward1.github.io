(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{406:function(t,v,_){"use strict";_.r(v);var r=_(2),s=Object(r.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[v("strong",[t._v("Table of Contents")]),t._v(" "),v("em",[t._v("generated with "),v("a",{attrs:{href:"https://github.com/thlorenz/doctoc",target:"_blank",rel:"noopener noreferrer"}},[t._v("DocToc"),v("OutboundLink")],1)])]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B"}},[t._v("NoSQL数据库简介")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E6%A6%82%E8%BF%B0"}},[t._v("概述")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95"}},[t._v("技术发展")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0"}},[t._v("NoSQL数据库概述")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#nosql%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"}},[v("strong",[t._v("NoSQL适用场景")])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#nosql%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"}},[v("strong",[t._v("NoSQL不适用场景")])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%92%E5%90%8D"}},[t._v("数据库排名")])])])])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#redis6%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85"}},[t._v("Redis6概述和安装")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"}},[t._v("应用场景")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E9%85%8D%E5%90%88%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%81%9A%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"}},[v("strong",[t._v("配合关系型数据库做高速缓存")])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E5%A4%9A%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE"}},[v("strong",[t._v("多样的数据结构存储持久化数据")])])])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#redis%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"}},[t._v("Redis的相关知识")])])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"}},[t._v("常用五大数据类型")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E9%94%AEkey%E6%93%8D%E4%BD%9C"}},[t._v("键（key）操作")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#redis%E5%AD%97%E7%AC%A6%E4%B8%B2string"}},[t._v("Redis字符串(String)")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"}},[t._v("常用命令")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"}},[t._v("数据结构")])])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#redis%E5%88%97%E8%A1%A8list"}},[t._v("Redis列表(List)")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"}},[t._v("常用命令")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"}},[t._v("数据结构")])])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#redis%E9%9B%86%E5%90%88set"}},[t._v("Redis集合(Set)")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"}},[t._v("常用命令")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"}},[t._v("数据结构")])])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#redis%E5%93%88%E5%B8%8Chash"}},[t._v("Redis哈希(Hash)")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"}},[t._v("常用命令")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3"}},[t._v("数据结构")])])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zset"}},[t._v("Redis有序集合Zset")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4"}},[t._v("常用命令")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4"}},[t._v("数据结构")])])])])])]),t._v(" "),v("li",[v("a",{attrs:{href:"#redis6%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"}},[t._v("Redis6配置文件详解")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"}},[t._v("Redis的发布和订阅")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"}},[t._v("什么是发布和订阅")])]),t._v(" "),v("li",[v("a",{attrs:{href:"#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0"}},[t._v("发布订阅命令行实现")])])])])]),t._v(" "),v("p",[v("strong",[t._v("学习自"),v("a",{attrs:{href:"https://www.bilibili.com/video/BV1Rv41177Af",target:"_blank",rel:"noopener noreferrer"}},[t._v("【尚硅谷】Redis 6 入门到精通 超详细 教程"),v("OutboundLink")],1)])]),t._v(" "),v("p",[t._v("参考文档：")]),t._v(" "),v("p",[t._v("http://redisdoc.com/")]),t._v(" "),v("p",[t._v("https://devdocs.io/")]),t._v(" "),v("p",[t._v("https://www.redis.net.cn/tutorial/3501.html")]),t._v(" "),v("h1",{attrs:{id:"nosql数据库简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nosql数据库简介"}},[t._v("#")]),t._v(" NoSQL数据库简介")]),t._v(" "),v("h2",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("p",[t._v("NoSQL(NoSQL = "),v("strong",[t._v("Not Only SQL")]),t._v(" )，意即“不仅仅是SQL”，泛指"),v("strong",[t._v("非关系型的数据库")]),t._v("。")]),t._v(" "),v("p",[t._v("NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("不遵循SQL标准。")])]),t._v(" "),v("li",[v("p",[t._v("不支持ACID。")])]),t._v(" "),v("li",[v("p",[t._v("远超于SQL的性能。")])])]),t._v(" "),v("h2",{attrs:{id:"技术发展"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#技术发展"}},[t._v("#")]),t._v(" 技术发展")]),t._v(" "),v("p",[v("strong",[t._v("解决CPU及内存压力")])]),t._v(" "),v("p",[v("strong",[t._v("解决IO压力")])]),t._v(" "),v("h2",{attrs:{id:"nosql数据库概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nosql数据库概述"}},[t._v("#")]),t._v(" NoSQL数据库概述")]),t._v(" "),v("h3",{attrs:{id:"nosql适用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nosql适用场景"}},[t._v("#")]),t._v(" "),v("strong",[t._v("NoSQL适用场景")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("对数据高并发的读写")])]),t._v(" "),v("li",[v("p",[t._v("海量数据的读写")])]),t._v(" "),v("li",[v("p",[t._v("对数据高可扩展性的")])])]),t._v(" "),v("h3",{attrs:{id:"nosql不适用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nosql不适用场景"}},[t._v("#")]),t._v(" "),v("strong",[t._v("NoSQL不适用场景")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("需要事务支持")])]),t._v(" "),v("li",[v("p",[t._v("基于sql的结构化查询存储，处理复杂的关系,需要即席查询。")])])]),t._v(" "),v("h3",{attrs:{id:"数据库排名"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库排名"}},[t._v("#")]),t._v(" 数据库排名")]),t._v(" "),v("p",[t._v("http://db-engines.com/en/ranking")]),t._v(" "),v("h1",{attrs:{id:"redis6概述和安装"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis6概述和安装"}},[t._v("#")]),t._v(" Redis6概述和安装")]),t._v(" "),v("p",[t._v("https://phoenixnap.com/kb/install-redis-on-ubuntu-20-04")]),t._v(" "),v("h2",{attrs:{id:"应用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),v("h3",{attrs:{id:"配合关系型数据库做高速缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#配合关系型数据库做高速缓存"}},[t._v("#")]),t._v(" "),v("strong",[t._v("配合关系型数据库做高速缓存")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("高频次，热门访问的数据，降低数据库IO")])]),t._v(" "),v("li",[v("p",[t._v("分布式架构，做session共享")])])]),t._v(" "),v("h3",{attrs:{id:"多样的数据结构存储持久化数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多样的数据结构存储持久化数据"}},[t._v("#")]),t._v(" "),v("strong",[t._v("多样的数据结构存储持久化数据")])]),t._v(" "),v("h2",{attrs:{id:"redis的相关知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis的相关知识"}},[t._v("#")]),t._v(" Redis的相关知识")]),t._v(" "),v("p",[v("strong",[t._v("Redis是单线程+多路IO复用技术")])]),t._v(" "),v("p",[t._v("多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）")]),t._v(" "),v("p",[v("strong",[t._v("串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)")])]),t._v(" "),v("h1",{attrs:{id:"常用五大数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用五大数据类型"}},[t._v("#")]),t._v(" 常用五大数据类型")]),t._v(" "),v("p",[t._v("redis常见数据类型操作命令http://www.redis.cn/commands.html")]),t._v(" "),v("h2",{attrs:{id:"键-key-操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#键-key-操作"}},[t._v("#")]),t._v(" 键（key）操作")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("命令")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("keys *")]),t._v(" "),v("td",[t._v("查看当前库的所有键")])]),t._v(" "),v("tr",[v("td",[t._v("exists")]),t._v(" "),v("td",[t._v("判断某个键是否存在")])]),t._v(" "),v("tr",[v("td",[t._v("type")]),t._v(" "),v("td",[t._v("查看键的类型")])]),t._v(" "),v("tr",[v("td",[t._v("del")]),t._v(" "),v("td",[t._v("删除某个键")])]),t._v(" "),v("tr",[v("td",[t._v("expire")]),t._v(" "),v("td",[t._v("为键值设置过期时间，单位秒")])]),t._v(" "),v("tr",[v("td",[t._v("ttl")]),t._v(" "),v("td",[t._v("查看还有多久过期,-1表示永不过期,-2表示已过期")])]),t._v(" "),v("tr",[v("td",[t._v("dbsize")]),t._v(" "),v("td",[t._v("查看当前数据库中key的数量")])]),t._v(" "),v("tr",[v("td",[t._v("flushdb")]),t._v(" "),v("td",[t._v("清空当前库")])]),t._v(" "),v("tr",[v("td",[t._v("Flushall")]),t._v(" "),v("td",[t._v("通杀全部库")])]),t._v(" "),v("tr",[v("td",[t._v("unlink")]),t._v(" "),v("td",[t._v("异步删除key")])]),t._v(" "),v("tr",[v("td",[t._v("flushdb async")]),t._v(" "),v("td",[t._v("异步清空当前库")])]),t._v(" "),v("tr",[v("td",[t._v("flushall async")]),t._v(" "),v("td",[t._v("异步通杀全部库")])])])]),t._v(" "),v("h2",{attrs:{id:"redis字符串-string"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis字符串-string"}},[t._v("#")]),t._v(" Redis字符串(String)")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。")]),t._v(" "),v("p",[t._v("String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。")]),t._v(" "),v("p",[t._v("String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M")])]),t._v(" "),v("li",[v("p",[v("img",{attrs:{src:"https://github.com/stanedward1/MyPicture/blob/master/Hexo/daabase/redis6/image-20211119010229946.png?raw=true",alt:"image-20211119010229946"}})])])]),t._v(" "),v("p",[v("strong",[t._v("所谓原子操作是指不会被线程调度机制打断的操作；")])]),t._v(" "),v("p",[v("strong",[t._v("这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。")])]),t._v(" "),v("p",[v("strong",[t._v('（1）在单线程中， 能够在单条指令中完成的操作都可以认为是"原子操作"，因为中断只能发生于指令之间。')])]),t._v(" "),v("p",[v("strong",[t._v("（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。")])]),t._v(" "),v("p",[v("strong",[t._v("Redis单命令的原子性主要得益于Redis的单线程。")])]),t._v(" "),v("h3",{attrs:{id:"常用命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用命令"}},[t._v("#")]),t._v(" 常用命令")]),t._v(" "),v("ul",[v("li",[v("table",[v("thead",[v("tr",[v("th",[t._v("命令")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("get")]),t._v(" "),v("td",[t._v("查询对应键值")])]),t._v(" "),v("tr",[v("td",[t._v("set")]),t._v(" "),v("td",[t._v("添加键值对")])]),t._v(" "),v("tr",[v("td",[t._v("mget")]),t._v(" "),v("td",[t._v("同时获取一个或多个value")])]),t._v(" "),v("tr",[v("td",[t._v("mset")]),t._v(" "),v("td",[t._v("同时设置一个或多个key-value对")])]),t._v(" "),v("tr",[v("td",[t._v("incr")]),t._v(" "),v("td",[t._v("将key中存储的数字值增1只能对数字值操作，如果为空，新增值为1")])]),t._v(" "),v("tr",[v("td",[t._v("decr")]),t._v(" "),v("td",[t._v("将key中存储的数字值减1只能对数字之操作，如果为空,新增值为-1")])]),t._v(" "),v("tr",[v("td",[t._v("incrby 步长")]),t._v(" "),v("td",[t._v("将key中存储的数字值增，自定义步长")])]),t._v(" "),v("tr",[v("td",[t._v("decrby 步长")]),t._v(" "),v("td",[t._v("将key中存储的数字值减，自定义步长")])]),t._v(" "),v("tr",[v("td",[t._v("strlen")]),t._v(" "),v("td",[t._v("获取值的长度")])]),t._v(" "),v("tr",[v("td",[t._v("setnx")]),t._v(" "),v("td",[t._v("只有在key 不存在时设置key的值")])]),t._v(" "),v("tr",[v("td",[t._v("setex <过期时间>")]),t._v(" "),v("td",[t._v("设置键值的同时，设置过去时间，单位秒")])]),t._v(" "),v("tr",[v("td",[t._v("append")]),t._v(" "),v("td",[t._v("追加")])])])])])]),t._v(" "),v("h3",{attrs:{id:"数据结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),v("p",[v("strong",[t._v("String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.")])]),t._v(" "),v("p",[v("strong",[t._v("字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。")])]),t._v(" "),v("h2",{attrs:{id:"redis列表-list"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis列表-list"}},[t._v("#")]),t._v(" Redis列表(List)")]),t._v(" "),v("p",[v("strong",[t._v("单键多值")])]),t._v(" "),v("p",[t._v("Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。")]),t._v(" "),v("p",[v("strong",[t._v("它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。")])]),t._v(" "),v("h3",{attrs:{id:"常用命令-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用命令-2"}},[t._v("#")]),t._v(" 常用命令")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("命令")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("lpush/rpush")]),t._v(" "),v("td",[t._v("从左边/右边插入一个或多个值。")])]),t._v(" "),v("tr",[v("td",[t._v("lpop/rpop")]),t._v(" "),v("td",[t._v("从左边/右边吐出一个值。值在键在，值光键亡。")])]),t._v(" "),v("tr",[v("td",[t._v("lrange")]),t._v(" "),v("td",[t._v("按照索引下标获得元素(从左到右)")])]),t._v(" "),v("tr",[v("td",[t._v("llen")]),t._v(" "),v("td",[t._v("获得列表长度")])]),t._v(" "),v("tr",[v("td",[t._v("linsert")]),t._v(" "),v("td",[t._v("在"),v("value",[t._v("的后面插入"),v("newvalue",[t._v("插入值")])],1)],1)]),t._v(" "),v("tr",[v("td",[t._v("lrem")]),t._v(" "),v("td",[t._v("从左边删除n个value(从左到右)")])]),t._v(" "),v("tr",[v("td",[t._v("lset")]),t._v(" "),v("td",[t._v("将列表key下标为index的值替换成value")])])])]),t._v(" "),v("h3",{attrs:{id:"数据结构-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-2"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),v("p",[t._v("List的数据结构为快速链表quickList。 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。")]),t._v(" "),v("p",[t._v("它将所有的元素紧挨着一起存储，分配的是一块连续的内存。 当数据量比较多的时候才会改成quicklist。")]),t._v(" "),v("p",[t._v("因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。")]),t._v(" "),v("p",[v("strong",[t._v("Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。")])]),t._v(" "),v("h2",{attrs:{id:"redis集合-set"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis集合-set"}},[t._v("#")]),t._v(" Redis集合(Set)")]),t._v(" "),v("p",[t._v("Redis set对外提供的功能与list类似是一个列表的功能，"),v("strong",[t._v("特殊之处在于set是可以自动排重的")]),t._v("，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。")]),t._v(" "),v("p",[v("strong",[t._v("Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。")])]),t._v(" "),v("p",[t._v("一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变.。")]),t._v(" "),v("h3",{attrs:{id:"常用命令-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用命令-3"}},[t._v("#")]),t._v(" 常用命令")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("命令")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("sadd …")]),t._v(" "),v("td",[t._v("将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的元素将被忽略")])]),t._v(" "),v("tr",[v("td",[t._v("srem …")]),t._v(" "),v("td",[t._v("删除元素")])]),t._v(" "),v("tr",[v("td",[t._v("smembers")]),t._v(" "),v("td",[t._v("取出该集合的所有值。")])]),t._v(" "),v("tr",[v("td",[t._v("sismember")]),t._v(" "),v("td",[t._v("判断集合是否为含有该值，有返回1，没有返回0")])]),t._v(" "),v("tr",[v("td",[t._v("scard")]),t._v(" "),v("td",[t._v("返回该集合的元素个数。")])]),t._v(" "),v("tr",[v("td",[t._v("srem")]),t._v(" "),v("td",[t._v("删除集合中的某个元素。")])]),t._v(" "),v("tr",[v("td",[t._v("srandmember")]),t._v(" "),v("td",[t._v("随机从该集合中取出n个值。不会从集合中删除")])]),t._v(" "),v("tr",[v("td",[t._v("spop")]),t._v(" "),v("td",[t._v("随机从该集合中吐出一个值。删除")])]),t._v(" "),v("tr",[v("td",[t._v("sdiff")]),t._v(" "),v("td",[t._v("返回两个集合的差集元素。")])]),t._v(" "),v("tr",[v("td",[t._v("sunion")]),t._v(" "),v("td",[t._v("返回两个集合的并集元素。")])]),t._v(" "),v("tr",[v("td",[t._v("smove")]),t._v(" "),v("td",[t._v("value把集合中一个值从一个集合移动到另一个集合")])]),t._v(" "),v("tr",[v("td",[t._v("sinter")]),t._v(" "),v("td",[t._v("返回两个集合的交集元素。")])])])]),t._v(" "),v("h3",{attrs:{id:"数据结构-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-3"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),v("p",[t._v("Set数据结构是dict字典，字典是用哈希表实现的。")]),t._v(" "),v("p",[t._v("Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。")]),t._v(" "),v("h2",{attrs:{id:"redis哈希-hash"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis哈希-hash"}},[t._v("#")]),t._v(" Redis哈希(Hash)")]),t._v(" "),v("p",[t._v("Redis hash 是一个键值对集合。")]),t._v(" "),v("p",[t._v("Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。")]),t._v(" "),v("p",[v("strong",[t._v("类似Java里面的Map<String,Object>")])]),t._v(" "),v("h3",{attrs:{id:"常用命令-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用命令-4"}},[t._v("#")]),t._v(" 常用命令")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("命令")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("hset")]),t._v(" "),v("td",[t._v("给集合中的 键赋值")])]),t._v(" "),v("tr",[v("td",[t._v("hget")]),t._v(" "),v("td",[t._v("从集合 取出 value")])]),t._v(" "),v("tr",[v("td",[t._v("hmset …")]),t._v(" "),v("td",[t._v("批量设置hash的值")])]),t._v(" "),v("tr",[v("td",[t._v("hexists")]),t._v(" "),v("td",[t._v("查看哈希表 key 中，给定域 field 是否存在。")])]),t._v(" "),v("tr",[v("td",[t._v("hmget")]),t._v(" "),v("td",[t._v("批量获取hash的值")])]),t._v(" "),v("tr",[v("td",[t._v("hgetall")]),t._v(" "),v("td",[t._v("获取所有字段值")])]),t._v(" "),v("tr",[v("td",[t._v("hlen")]),t._v(" "),v("td",[t._v("获取某个key内的全部数量")])]),t._v(" "),v("tr",[v("td",[t._v("hincrby")]),t._v(" "),v("td",[t._v("为哈希表 key 中的域 field 的值加上增量 1  -1")])]),t._v(" "),v("tr",[v("td",[t._v("hsetnx")]),t._v(" "),v("td",[t._v("将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在")])]),t._v(" "),v("tr",[v("td",[t._v("hdel")]),t._v(" "),v("td",[t._v("删除一个key")])])])]),t._v(" "),v("h3",{attrs:{id:"数据结构-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-4"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),v("p",[t._v("Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。")]),t._v(" "),v("h2",{attrs:{id:"redis有序集合zset"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis有序集合zset"}},[t._v("#")]),t._v(" Redis有序集合Zset")]),t._v(" "),v("p",[t._v("Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。")]),t._v(" "),v("p",[t._v("不同之处是有序集合的每个成员都关联了一个**评分（**score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。")]),t._v(" "),v("p",[t._v("因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。")]),t._v(" "),v("p",[t._v("访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。")]),t._v(" "),v("h3",{attrs:{id:"常用命令-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用命令-5"}},[t._v("#")]),t._v(" 常用命令")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("命令")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("zadd")]),t._v(" "),v("td",[t._v("将一个或多个 member 元素及其 score 值加入到有序集 key 当中")])]),t._v(" "),v("tr",[v("td",[t._v("zrange [WITHSCORES]")]),t._v(" "),v("td",[t._v("返回有序集 key 中，下标在 之间的元素带WITHSCORES，可以让分数一起和值返回到结果集。")])]),t._v(" "),v("tr",[v("td",[t._v("zrevrange [WITHSCORES]")]),t._v(" "),v("td",[t._v("同上，改为从大到小排列。")])]),t._v(" "),v("tr",[v("td",[t._v("zscore member")]),t._v(" "),v("td",[t._v("获取元素的分数")])]),t._v(" "),v("tr",[v("td",[t._v("zrem")]),t._v(" "),v("td",[t._v("删除该集合下，指定值的元素")])]),t._v(" "),v("tr",[v("td",[t._v("zrank")]),t._v(" "),v("td",[t._v("返回该值在集合中的排名，从小到大")])]),t._v(" "),v("tr",[v("td",[t._v("zrevrank")]),t._v(" "),v("td",[t._v("返回该值在集合中的排名，从大到小")])]),t._v(" "),v("tr",[v("td",[t._v("zrangebyscore key min max [withscores] [limit offset count]")]),t._v(" "),v("td",[t._v("返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。")])]),t._v(" "),v("tr",[v("td",[t._v("zrevrangebyscore key max min [withscores] [limit offset count]")]),t._v(" "),v("td",[t._v("同上，改为从大到小排列。")])]),t._v(" "),v("tr",[v("td",[t._v("zincrby")]),t._v(" "),v("td",[t._v("为元素的score加上增量")])]),t._v(" "),v("tr",[v("td",[t._v("zcard")]),t._v(" "),v("td",[t._v("获取集合中元素的数量")])]),t._v(" "),v("tr",[v("td",[t._v("ZCOUNT key min max")]),t._v(" "),v("td",[t._v("获得指定分数范围内的元素个数")])])])]),t._v(" "),v("h3",{attrs:{id:"数据结构-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-5"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),v("p",[t._v("SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map<String, Double>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。")]),t._v(" "),v("p",[t._v("zset底层使用了两个数据结构")]),t._v(" "),v("p",[t._v("（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。")]),t._v(" "),v("p",[t._v("（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。")]),t._v(" "),v("h1",{attrs:{id:"redis6配置文件详解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis6配置文件详解"}},[t._v("#")]),t._v(" Redis6配置文件详解")]),t._v(" "),v("p",[t._v("https://docs.bitnami.com/installer/apps/redash/get-started/understand-default-config/")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6844903589270257678",target:"_blank",rel:"noopener noreferrer"}},[t._v("配置Redis服务器、设置密码并允许IP访问"),v("OutboundLink")],1)]),t._v(" "),v("h1",{attrs:{id:"redis的发布和订阅"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis的发布和订阅"}},[t._v("#")]),t._v(" Redis的发布和订阅")]),t._v(" "),v("h2",{attrs:{id:"什么是发布和订阅"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是发布和订阅"}},[t._v("#")]),t._v(" 什么是发布和订阅")]),t._v(" "),v("p",[v("strong",[t._v("Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。")])]),t._v(" "),v("p",[t._v("Redis 客户端可以订阅任意数量的频道。")]),t._v(" "),v("h2",{attrs:{id:"发布订阅命令行实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅命令行实现"}},[t._v("#")]),t._v(" 发布订阅命令行实现")]),t._v(" "),v("div",{staticClass:"language-shell extra-class"},[v("pre",{pre:!0,attrs:{class:"language-shell"}},[v("code",[t._v("SUBSCRIBE channel1\npublish channel1 hello\n")])])]),v("p",[t._v("发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息")])])}),[],!1,null,null,null);v.default=s.exports}}]);